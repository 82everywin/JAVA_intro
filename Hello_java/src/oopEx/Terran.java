package oopEx;
/*
 * 객체지향에서의 클래스 : 객체의 원형(Prototype or 명세서 or 설계도)이다.
 * 즉 모든 객체는 클래스가 존재해야 만들어 낼 수 있다. 
 * 이렇게 만들어진 객체는 객체의 타입에 항상 클래스타입을 꼬리표처럼 달고 다닌다.중요합니다.
 * 하나의 클래스를 바탕으로 파생된 (생성된) 객체는 다 틀린 객체지만, 클래스 타입은 같다. 
 * 
 * 클래스는 크게 객체의 상태를 나타내는 속성(properties)와 기능을 정의하는 method 로 정의할 수 있다. 
 * 물론 !!객체를 생성하는!! 실제 역할을 하는 생성자(바로배움)도 정의할 수도 있다. (만약 하지 않는 경우엔 컴파일시에 컴파일러가 default 생성자 제공함)
 */

public abstract class Terran extends Object{

	String unitType; //Terran 종족 중 유닛 객체가 생성이 되면 이 필드를 통해 어떤 유닛인지 알 수 있도록 한다. 

	//생성자
	public Terran(String unitType) {
		this.unitType=unitType;
	}
	
	// 테란유닛들이 말할 수있는(Speaking) 기능을 테란에서 선언해본다. 
	
	// 추상(abstract)메서드 : 메서드가 자신 클래스의 목적이 아닌 상속 및 오버라이드가 주목적인 메서드를 추상메서드라고 한다. 
	// 이 추상메서드는 abstract라는 키워드를 이용해서 선언해야하고, 반드시 메서드 리턴타입 전에 선언 되어야 한다.
	// 이렇게 추상메서드를 하나 이상 보유한 클래스는 반드시 추상 클래스로 선언이 되어야 한다. 반드시!!!!
	// 이렇게 추상 클래스로 선언이 되어진 클래스는 자신의 Instance를 생성할 수 없게 된다. 하지만  Type Ref 변수로는 사용가능하다. 
	// 추상 클래스를 상속 받은 클래스(자식클래스는) 무조건 추상메서드를 오버라이드하거나, 그렇지 않은 경우 자신또한 추상클래스로 선언 되어야 한다. 
	public abstract void Speak() ; 
	
	/*
	 * 메서드 오버라이딩(Override) : 상속받은 부모의 메서드가 자식의 목적이 아닌 부모의 목적으로 정의되었을 떄, 
	 * 해당 메서드를 자식의 목적으로 재정의(Override) 해서 사용하는 형태를 말한다. 이렇게 오버라이드 된 부모 메서드는 자식의 메서드로 인해 은닉(hidden) 되어지기 떄문에
	 * 자식 객체를 생성한 상태에서는 더이상 호출되어지지 않는다. 
	 * 오버라이드를 하는 메서드는 부모의 그것과 모두 같아야 한다.(리턴타입, 메서드명, 파라미터까지) 단, 접근제어자(public>protected>default>private)는 
	 * 부모와 같거나 더 크면 상관없다. 
	 */
	public String toString() { // 테란의 유닛타입을 문자열로 return 하는 메서드 정의.
		return "이것은 " + this.unitType;
	}
	
	
}
	